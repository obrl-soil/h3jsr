#' Convert H3 addresses to a line
#'
#' Return line geometry for a sequence of H3 addresses in WGS84 coordinates.
#' @param input Character vector of 15-character addresses generated by H3, a
#'   list of such, or a data frame where the last column is a list-column of H3
#'   addresses (usually the output of
#'   \code{\link[h3jsr:grid_path]{h3jsr::grid_path()}}.
#' @param simple Logical; whether to return an `sfc_LINESTRING` object or an `sf`
#'   data frame containing both inputs and outputs.
#' @return An `sfc_LINESTRING` object containing a line for each vector of H3
#'   addresses supplied. If simple = FALSE, an `sf` object including the input
#'   data.
#' @note This function can accept any arbitrary vector of addresses (including
#'   addresses at multiple resolutions) but results may be unexpected. It is
#'   assumed that addresses are supplied in a pre-ordered fashion.
#' @import V8
#' @examples
#' # What is the hexagon over the Brisbane Town Hall at resolution 10?
#' brisbane_hex_10 <- h3_to_polygon(input = '8abe8d12acaffff')
#'
#' # Give me a some nearby hexagons
#' hex_sample <- get_kring_list('8abe8d12acaffff', 4)[[1]][[4]][seq(1,18,3)]
#' hex_sample_polys <- h3_to_polygon(hex_sample)
#'
#' # find connecting paths
#' paths <- grid_path(rep('8abe8d12acaffff', 6), hex_sample)
#'
#' # make lines
#' lines <- h3_to_line(paths)
#'
#'\dontrun{
#' plot(hex_sample_polys, reset = FALSE)
#' plot(brisbane_hex_10, add = TRUE)
#' plot(lines, col = 'red', add = TRUE)
#' }
#'
#' @importFrom sf st_linestring st_sfc st_sf
#' @export
#'
h3_to_line <- function(input = NULL, simple = TRUE) {
  UseMethod('h3_to_line')
}

#' @rdname h3_to_line
#' @inherit h3_to_line return
#' @method h3_to_line data.frame
#' @export
#'
h3_to_line.data.frame <- function(input = NULL, simple = TRUE) {
  # last col taken to be source of addresses
  hex_points <- lapply(input[[ncol(input)]], h3_to_point, simple = TRUE)
  hex_lines <- lapply(hex_points, function(l) {
    interleaved <- rbind(l[1:(length(l) - 1)], l[2:length(l)])
    matrified <- lapply(interleaved, as.matrix, ncol = 2, byrow = T)
    rbound <- do.call('rbind', matrified)
    st_linestring(rbound)
  })

  if(simple == TRUE) {
    sf::st_sfc(hex_lines, crs = 4326)
  } else {
    sf::st_sf(input, 'geometry' = sf::st_sfc(hex_lines, crs = 4326))
  }
}

#' @rdname h3_to_line
#' @inherit h3_to_line return
#' @method h3_to_line list
#' @export
#'
h3_to_line.list <- function(input = NULL, simple = TRUE) {
  hex_points <- lapply(input, h3_to_point, simple = TRUE)
  hex_lines <- lapply(hex_points, function(l) {
    interleaved <- rbind(l[1:(length(l) - 1)], l[2:length(l)])
    matrified <- lapply(interleaved, as.matrix, ncol = 2, byrow = T)
    rbound <- do.call('rbind', matrified)
    st_linestring(rbound)
  })

  if(simple == TRUE) {
    sf::st_sfc(hex_lines, crs = 4326)
  } else {
    out <- sf::st_sf('geometry' = sf::st_sfc(hex_lines, crs = 4326))
    out$input <- input
    sf::st_sf(out)
  }
}

#' @rdname h3_to_line
#' @inherit h3_to_line return
#' @method h3_to_line character
#' @export
#'
h3_to_line.character <- function(input = NULL, simple = TRUE) {
    points <- h3_to_point(input, simple = TRUE)
    interleaved <- rbind(points[1:(length(points) - 1)],
                         points[2:length(points)])
    matrified <- lapply(interleaved, as.matrix, ncol = 2, byrow = T)
    rbound <- do.call('rbind', matrified)
    lined <- st_linestring(rbound)

  if(simple == TRUE) {
    sf::st_sfc(lined, crs = 4326)
  } else {
    out <- sf::st_sf('geometry' = sf::st_sfc(lined, crs = 4326))
    out$input <- list(input)
    sf::st_sf(out)
  }
}
